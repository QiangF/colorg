#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright © 2013 Progiciels Bourbeau-Pinard inc.
# François Pinard <pinard@iro.umontreal.ca>, 2013.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.  */

"""\
ColOrg server, to orchestrate collobaration between many ColOrg users.

ColOrg is a real-time collaborative editing tool originally meant for
Emacs Org mode users.  See https://github.com/pinard/ColOrg/wiki/.

Usage: colorg-server [OPTION]... [HOST] [PORT]

Options:
  -d   Debug all communication.
  -h   Print this help, and do nothing else.

If HOST is specified, listen for connections on HOST instead of 0.0.0.0.
If PORT is specified, listen for connections on PORT rather than on 7997.
PORT being recognized as a decimal number, HOST may be omitted.
"""

__metaclass__ = type
import datetime
import gevent
from gevent import socket
import hashlib
import json
import sys

md5_empty = 'd41d8cd98f00b204e9800998ecf8427e'


class Error(Exception):
    pass


class Warn(Exception):
    pass


class Main:
    debug = False
    host = '0.0.0.0'
    port = 7997

    def main(self, *arguments):
        "Main entry point."

        # Decode options.
        import getopt
        options, arguments = getopt.getopt(arguments, 'dh')
        for option, value in options:
            if option == '-d':
                self.debug = True
            elif option == '-h':
                sys.stdout.write(__doc__)
                return
        if len(arguments) == 1 and arguments[0].isdigit():
            self.port = int(arguments[0])
        else:
            if len(arguments) >= 1:
                self.host = arguments[0]
            if len(arguments) >= 2:
                self.port = int(arguments[1])
            if len(arguments) > 2:
                sys.exit("More than 2 arguments.  Try %s -h for help."
                         % sys.argv[0])

        # Start it all.
        try:
            gevent.spawn(self.listener).join()
        except KeyboardInterrupt:
            sys.stderr.write('\n')

    def listener(self):
        "To each new connection, assign a User."
        handle = socket.socket()
        handle.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
        handle.bind((self.host, self.port))
        handle.listen(1)
        self.report("ColOrg server accepting connections on %s, port %d.",
                    self.host, self.port)
        while True:
            handle2, address = handle.accept()
            User(handle2, *address).start()

    def report(self, format, *arguments):
        sys.stderr.write('%s\n' % (format % arguments).rstrip())


class Resource:
    ordinal = 0
    registry = {}

    def __init__(self, name):
        self.name = name
        self.ordinal = Resource.ordinal
        Resource.ordinal += 1
        Resource.registry[self.ordinal] = self
        self.contents = ''
        self.users = []

    def __repr__(self):
        return repr(self.name)

    def alter(self, start, end, string):
        self.contents = self.contents[:start] + string + self.contents[end:]

    @staticmethod
    def get(name):
        if isinstance(name, int):
            return Resource.registry.get(name)
        for key, resource in Resource.registry.iteritems():
            if name == resource.name:
                return resource

    def get_contents(self):
        return self.contents

    def md5sum(self):
        return hashlib.md5(self.contents).hexdigest()


class User(gevent.Greenlet):
    name = "Anonymous"
    ordinal = 0
    registry = {}

    def __init__(self, handle, host, port):
        self.ordinal = User.ordinal
        User.ordinal += 1
        User.registry[self.ordinal] = self
        super(User, self).__init__()
        self.input = handle.makefile()
        self.output = handle.makefile('w', 0)
        self.host = host
        self.port = port
        self.report_id = '%s:%d' % (host, port)
        self.report("%s Incoming connection.", self.report_id)
        # User commands waiting to be processed on the server.
        self.incoming_queue = []
        # Server commands waiting to be polled and read by the client.
        self.outgoing_queue = []

    def _run(self):

        # Process incoming commands.
        while True:
            line = self.input.readline()
            if not line:
                self.report("%s Disconnected.", self.report_id)
                break
            if run.debug:
                self.report("%s %s", self.report_id, line.rstrip())
            try:
                try:
                    command = json.loads(line)
                except ValueError, exception:
                    raise Warn(str(exception))
                result = self.dispatch(command)
            except Error, exception:
                result = ['error', str(exception)]
            except Warn, exception:
                result = ['warn', str(exception)]
            text = json.dumps(result)
            assert '\n' not in text, repr(text)
            if run.debug:
                self.report("%s %s", ' ' * len(self.report_id), text)
            self.output.write(text + '\n')

        # Leave all resources.
        for resource in Resource.registry.itervalues():
            if self in resource.users:
                resource.users.remove(self)

    def dispatch(self, command):
        if command and isinstance(command, list):
            action = command[0]
            arguments = command[1:]
        else:
            action = command
            arguments = ()
        processor = getattr(self, 'do_%s' % action, None)
        if processor is None:
            raise Warn("Unrecognized command: %r" % command)
        try:
            return processor(*arguments)
        except TypeError, exception:
            raise Warn(str(exception))

    def do_alter(self, resource, start, end, string):
        resource = self.resolve_resource(resource)
        if self not in resource.users:
            raise Error("Resource not monitored: %r" % resource)
        resource.alter(start, end, string)
        for client in resource.users:
            if client is not self:
                client.outgoing_queue.append(
                    ('alter', resource.ordinal, start, end, string,
                     self.ordinal))
        return 'done'

    def do_chat(self, user, string):
        user = self.resolve_user(user)
        user.outgoing_queue.append(['chat', self.ordinal, string])
        return 'done'

    def do_create(self, name):
        if not isinstance(name, (str, unicode)):
            raise Warn("Name should be a string: %r" % name)
        if Resource.get(name) is not None:
            raise Warn("Resource name already taken: %r" % name)
        resource = Resource(name)
        resource.users.append(self)
        return ['done', resource.ordinal]

    def do_join(self, resource, md5sum):
        resource = self.resolve_resource(resource)
        if self in resource.users:
            raise Warn("Already monitoring: %r" % resource)
        if md5sum == md5_empty:
            self.outgoing_queue.append(
                ('alter', resource.ordinal, 0, 0, resource.get_contents(), 0))
        elif md5sum != resource.md5sum():
            raise Warn("Checksums do not match: %r %s here, %s remotely."
                       % resource, resource.md5sum(), md5sum)
        resource.users.append(self)
        return ['done', resource.ordinal]

    def do_leave(self, resource):
        resource = self.resolve_resource(resource)
        if self not in resource.users:
            raise Warn("Was not monitoring: %r" % resource)
        resource.users.remove(self)
        return 'done'

    def do_login(self, name):
        if not isinstance(name, (str, unicode)):
            raise Warn("Name should be a string: %r" % name)
        if User.get(name) is not None:
            raise Warn("User name already taken: %r" % name)
        self.name = name
        self.report_id = name
        return ['done', self.ordinal]

    def do_logout(self):
        if self.name is User.name:
            raise Warn("Not logged in: %r" % self)
        del self.name
        return ['done', self.ordinal]

    def do_resources(self):
        return ['done'] + [
            [key, resource.name]
             for key, resource in sorted(Resource.registry.items())]

    def do_poll(self, *subcommands):
        for command in subcommands:
            result = self.dispatch(command)
            if isinstance(result, (str, unicode)):
                return result
        queue = self.outgoing_queue
        self.outgoing_queue = []
        if queue:
            return ['exec'] + queue
        return 'exec'

    def do_users(self):
        return ['done'] + [
            [key, client.name]
             for key, client in sorted(User.registry.items())]

    @staticmethod
    def get(name):
        if isinstance(name, int):
            return User.registry.get(name)
        for key, client in User.registry.iteritems():
            if name == client.name:
                return client

    def report(self, format, *arguments):
        now = datetime.datetime.now().time()
        run.report('%.2d:%.2d:%.2d ' + format,
                   now.hour, now.minute, now.second, *arguments)

    def resolve_resource(self, resource):
        found = Resource.get(resource)
        if found is None:
            raise Warn("Resource not found: %r" % resource)
        return found

    def resolve_user(self, user):
        found = User.get(user)
        if found is None:
            raise Warn("User not found: %r" % user)
        return found


run = Main()
main = run.main

if __name__ == '__main__':
    main(*sys.argv[1:])
