#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright © 2013 Progiciels Bourbeau-Pinard inc.
# François Pinard <pinard@iro.umontreal.ca>, 2013.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.  */

"""\
colorg server, to orchestrate collobaration between many colorg users.

colorg is a real-time collaborative editing tool originally meant for
Emacs Org mode users.  See https://github.com/pinard/colorg/wiki/.

Usage: colorg-server [OPTION]... [HOST] [PORT]

Options:
  -d   Debug all communication (double to get the polling as well).
  -h   Print this help, and do nothing else.

If HOST is specified, listen for connections on HOST instead of 0.0.0.0.
If PORT is specified, listen for connections on PORT rather than on 7997.
PORT being recognized as a decimal number, HOST may be omitted.
"""

__metaclass__ = type
import datetime
import gevent
from gevent import socket
import hashlib
import json
import sys


welcome = 'colorg v1'
encoding = 'UTF-8'
md5_empty = 'd41d8cd98f00b204e9800998ecf8427e'
localhost = '127.0.0.1'


class Error(Exception):
    pass


class Warn(Exception):
    pass


class Main:
    debug = 0
    host = '0.0.0.0'
    port = 7997

    def main(self, *arguments):
        "Main entry point."

        # Decode options.
        import getopt
        options, arguments = getopt.getopt(arguments, 'dh')
        for option, value in options:
            if option == '-d':
                self.debug += 1
            elif option == '-h':
                sys.stdout.write(__doc__)
                return
        if len(arguments) == 1 and arguments[0].isdigit():
            self.port = int(arguments[0])
        else:
            if len(arguments) >= 1:
                self.host = arguments[0]
            if len(arguments) >= 2:
                self.port = int(arguments[1])
            if len(arguments) > 2:
                sys.exit("More than 2 arguments.  Try %s -h for help."
                         % sys.argv[0])

        # Start it all.
        try:
            gevent.spawn(self.listener).join()
        except KeyboardInterrupt:
            sys.stderr.write('\n')

    def listener(self):
        "For each new connection, create a Client task to handle it."
        handle = socket.socket()
        handle.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
        handle.bind((self.host, self.port))
        handle.listen(1)
        self.report("colorg server accepting connections on %s, port %d.",
                    self.host, self.port)
        while True:
            handle2, address = handle.accept()
            Client(handle2, *address).start()

    def report(self, format, *arguments):
        sys.stderr.write('%s\n' % (format % arguments).rstrip())


class Canonical(list):
    """\
A Canonical is a sequence of [FIRST, DELETED, INSERT, USER] lists, for
which all lists describe independant changes: there is no kind of
overlap between them.  Moreover, inserts are concatenated when feasible.
No two lists in a canonical sequence share the same FIRST field, and
these are kept in increasing order within the sequence.
"""

    def add_straight(self, first2, deleted2, insert2, user2):
        """\
Add a triplet to a Canonical, with strict obedience in case of clashes.
This is for modification sets all originating from the same user.
"""
        # Find INDEX where the new modification should be added or merged.
        delta2 = len(insert2) - deleted2
        index = len(self)
        while index > 0 and first2 < self[index - 1][0]:
            index -= 1
            self[index][0] += delta2
            first2 -= len(self[index][2]) - self[index][1]
        # If possible, concatenate a pure insert with the previous one.
        if index == 0:
            merge = False
        else:
            merge = self[index - 1][0] + len(self[index - 1][2]) == first2
        if merge:
            index -= 1
            self[index][1] += deleted2
            self[index][2] += insert2
        else:
            self.insert(index, [first2, deleted2, insert2, user2])
        # FIXME!
        # The new modification exists at INDEX.  Now, simplify forward.

    def add_cautious(self, first2, deleted2, insert2, user2):
        """\
Add a triplet to a Canonical, being cautious to not lose anything:
deletes are done once at most, previous inserts are never deleted.
This is for modification sets coming from different users.
"""
        pass   # FIXME!

    def relocate(self, first2, deleted2, insert2):
        "Return FIRST2 as it should be if this Canonical was applied first."
        after2 = first2 + len(insert2)
        for first, deleted, insert, user in self:
            # Nothing to do if the command appears later in the buffer.
            if after2 > first:
                after = first + len(insert)
                if first2 > after:
                    # Merely shift if the command appears sooner.
                    delta = after2 - first - deleted
                    first2 += delta
                else:
                    # FIXME!
                    pass
        return first2


class Client(gevent.Greenlet):
    "Receive all requests from a single client.  Produce a reply for each."
    ordinal = 0
    registry = {}
    login = None

    def __init__(self, handle, host, port):
        super(Client, self).__init__()
        self.ordinal = Client.ordinal
        Client.ordinal += 1
        Client.registry[self.ordinal] = self
        self.input = handle.makefile()
        self.output = handle.makefile('w', 0)
        self.host = host
        self.port = port
        self.report("%r Incoming connection.", self)
        text = '"%s"' % welcome
        if run.debug:
            self.report("%s %s", ' ' * len(repr(self)), text)
        self.output.write(text + '\n')
        self.outgoing_queue = []

    def __repr__(self):
        return '%s@%s:%d' % (
            '<?>' if self.login is None else self.login,
            'localhost' if self.host == localhost else self.host,
            self.port)

    def _run(self):

        # Process incoming commands.
        while True:
            line = self.input.readline()
            if not line:
                self.report("%r Disconnected.", self)
                break
            if run.debug and (run.debug > 1 or line != '"poll"\n'):
                self.report("%r %s", self, line.rstrip())
            try:
                try:
                    command = json.loads(line)
                except ValueError, exception:
                    raise Warn(str(exception))
                result = self.dispatch(command)
            except Error, exception:
                result = ['error', str(exception)]
            except Warn, exception:
                result = ['warn', str(exception)]
            text = json.dumps(result)
            assert '\n' not in text, repr(text)
            if run.debug and (run.debug > 1 or text != '"exec"'):
                self.report("%s %s", ' ' * len(repr(self)), text)
            self.output.write(text + '\n')

        # Leave all resources.
        for resource in Resource.registry.itervalues():
            if self in resource.clients:
                resource.clients.remove(self)

    def dispatch(self, command):
        if command and isinstance(command, list):
            action = command[0]
            arguments = command[1:]
        else:
            action = command
            arguments = ()
        processor = getattr(self, 'do_%s' % action, None)
        if processor is None:
            raise Warn("Unrecognized command: %r" % command)
        try:
            return processor(*arguments)
        except TypeError, exception:
            raise Warn(str(exception))

    def do_alter(self, resource, first, deleted, insert, include_self=False):
        resource = self.resolve_resource(resource)
        if self not in resource.clients:
            raise Error("Resource is not monitored: %r" % resource)
        resource.alter(first, deleted, insert)
        for client in resource.clients:
            if include_self or client is not self:
                client.outgoing_queue.append(
                    ('alter', resource.ordinal, first, deleted, insert,
                     self.ordinal))
        return 'done'

    def do_chat(self, user, insert):
        client = self.resolve_user(user)
        client.outgoing_queue.append(['chat', self.ordinal, insert])
        return 'done'

    def do_create(self, name):
        if not isinstance(name, (str, unicode)):
            raise Warn("Name should be a string: %r" % name)
        if Resource.get(name) is not None:
            raise Warn("Resource name is already taken: %r" % name)
        resource = Resource(name)
        resource.clients.append(self)
        return ['done', resource.ordinal]

    def do_join(self, resource, md5sum):
        resource = self.resolve_resource(resource)
        if self in resource.clients:
            raise Warn("Already monitoring: %r" % resource)
        if md5sum == md5_empty:
            self.outgoing_queue.append(
                ('alter', resource.ordinal, 0, 0, resource.get_contents(), 0))
        elif md5sum != resource.md5sum():
            raise Warn("Checksums do not match: %r %s here, %s remotely."
                       % (resource, resource.md5sum(), md5sum))
        resource.clients.append(self)
        return ['done', resource.ordinal]

    def do_leave(self, resource):
        resource = self.resolve_resource(resource)
        if self not in resource.clients:
            raise Warn("Was not monitoring: %r" % resource)
        resource.clients.remove(self)
        return 'done'

    def do_login(self, name):
        if not isinstance(name, (str, unicode)):
            raise Warn("Login name should be a string: %r" % name)
        self.login = name
        return ['done', self.ordinal]

    def do_logout(self):
        if self.login is None:
            raise Warn("Not logged in: %r" % self)
        del self.login
        return 'done'

    def do_resources(self):
        return ['done'] + [
            [resource.name, key]
            for key, resource in sorted(Resource.registry.items())]

    def do_poll(self, *subcommands):
        # Group incoming commands into canonicals, according to resources.
        incoming_by_resource = {}
        for command in subcommands:
            if command[0] == 'alter':
                _, resource, first, deleted, insert = command
                incoming = incoming_by_resource.get(resource)
                if incoming is None:
                    incoming = incoming_by_resource[resource] = Canonical()
                incoming.add_straight(first, deleted, insert, None)
            else:
                raise Error("Expecting an alter command: %r" % command)
        # Group outgoing commands into canonicals, according to resources.
        outgoing_by_resource = {}
        outgoing_queue = []
        for command in self.outgoing_queue:
            if command[0] == 'alter':
                _, resource, first, deleted, insert, user = command
                outgoing = outgoing_by_resource.get(resource)
                if outgoing is None:
                    outgoing = outgoing_by_resource[resource] = Canonical()
                outgoing.add_straight(first, deleted, insert, user)
            else:
                outgoing_queue.append(command)
        self.outgoing_queue = []
        # Handle each resource separately.
        for resource in set(incoming_by_resource) | set(outgoing_by_resource):
            incoming = incoming_by_resource.get(resource)
            outgoing = outgoing_by_resource.get(resource)
            if outgoing is None:
                # We only have INCOMING.
                for first, deleted, insert, user in incoming:
                    self.do_alter(resource, first, deleted, insert)
            elif incoming is None:
                # We only have OUTGOING.
                for first, deleted, insert, user in outgoing:
                    outgoing_queue.append(['alter', resource,
                                           first, deleted, insert, user])
            else:
                # We have both INCOMING and OUTGOING.
                undos = []
                redos = []
                for first, deleted, insert, user in incoming:
                    undos.append(['alter', resource, first, len(insert),
                                  deleted, self.ordinal])
                    first = outgoing.relocate(first, deleted, insert)
                    redos.append([first, deleted, insert])
                for first, deleted, insert in redos:
                    self.do_alter(resource, first, deleted, insert,
                                  include_self=True)
                undos.reverse()
                outgoing_queue = undos + outgoing_queue
        if outgoing_queue:
            return ['exec'] + outgoing_queue
        return 'exec'

    def do_users(self):
        return ['done'] + [
            [repr(client), key]
            for key, client in sorted(Client.registry.items())]

    @staticmethod
    def get(name):
        if isinstance(name, int):
            return Client.registry.get(name)
        for key, client in Client.registry.iteritems():
            if name == client.name:
                return client

    def report(self, format, *arguments):
        now = datetime.datetime.now().time()
        run.report('%.2d:%.2d:%.2d ' + format,
                   now.hour, now.minute, now.second, *arguments)

    def resolve_resource(self, resource):
        "Return the Resource structure for a given RESOURCE name or number."
        found = Resource.get(resource)
        if found is None:
            raise Warn("Resource is not found: %r" % resource)
        return found

    def resolve_user(self, user):
        "Return the Client structure for a given USER name or number."
        client = Client.get(user)
        if client is None:
            raise Warn("User is not found: %r" % user)
        return client


class Resource:
    ordinal = 0
    registry = {}

    def __init__(self, name):
        self.name = name
        self.ordinal = Resource.ordinal
        Resource.ordinal += 1
        Resource.registry[self.ordinal] = self
        self.contents = ''
        self.clients = []

    def __repr__(self):
        return repr(self.name)

    def alter(self, first, deleted, insert):
        self.contents = (self.contents[:first]
                         + insert
                         + self.contents[first + deleted:])

    @staticmethod
    def get(name):
        if isinstance(name, int):
            return Resource.registry.get(name)
        for key, resource in Resource.registry.iteritems():
            if name == resource.name:
                return resource

    def get_contents(self):
        return self.contents

    def md5sum(self):
        return hashlib.md5(self.contents.encode(encoding)).hexdigest()


run = Main()
main = run.main

if __name__ == '__main__':
    main(*sys.argv[1:])
