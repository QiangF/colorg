#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright © 2013 Progiciels Bourbeau-Pinard inc.
# François Pinard <pinard@iro.umontreal.ca>, 2013.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.  */

"""\
ColOrg is a real-time collaborative editing tool meant for Emacs
Org mode users.  See https://github.com/pinard/ColOrg/wiki/.

This is the ColOrg server.
"""

__metaclass__ = type
import gevent
from gevent import socket
import hashlib
import json
import sys

md5_empty = 'd41d8cd98f00b204e9800998ecf8427e'


class Error(Exception):
    pass


class Main:
    debug = False
    host = '0.0.0.0'
    port = 7997

    def main(self, *arguments):
        """\
ColOrg server.  Orchestrate collobaration between many ColOrg clients.

Usage: colorg-server [OPTION]...

Options:
  -d        Debug all communication.
  -h HOST   Listen for connections on HOST instead of 0.0.0.0.
  -p PORT   Listen for connections on PORT rather than on 7997.
"""

        # Decode options.
        import getopt
        options, arguments = getopt.getopt(arguments, 'dh:p:')
        for option, value in options:
            if option == '-d':
                self.debug = True
            elif option == '-h':
                self.host = value
            elif option == '-p':
                self.port = int(value)
        assert not arguments, arguments

        # Start it all.
        try:
            gevent.spawn(self.listener).join()
        except KeyboardInterrupt:
            sys.stderr.write('\n')

    def listener(self):
        "To each new connection, assign a Client."
        handle = socket.socket()
        handle.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
        handle.bind((self.host, self.port))
        handle.listen(1)
        self.echo("ColOrg server accepting connections on %s, port %d.",
                  self.host, self.port)
        while True:
            handle2, address = handle.accept()
            Client(handle2, address).start()

    def echo(self, format, *arguments):
        sys.stderr.write('%s\n' % (format % arguments).rstrip())


class Client(gevent.Greenlet):
    name = "Anonymous"
    ordinal = 0
    registry = {}

    def __init__(self, handle, address):
        self.ordinal = Client.ordinal
        Client.ordinal += 1
        Client.registry[self.ordinal] = self
        super(Client, self).__init__()
        self.input = handle.makefile()
        self.output = handle.makefile('w', 0)
        self.host, self.port = address
        self.echo("Incoming connection.")
        # Server commands waiting to be polled and read by the client.
        self.queue = []

    def _run(self):

        # Process incoming commands.
        while True:
            line = self.input.readline()
            if not line:
                self.echo("Disconnected.")
                break
            if run.debug:
                self.echo("Got: %r", line)
            try:
                try:
                    command = json.loads(line)
                except ValueError, exception:
                    raise Error(str(exception))
                result = self.dispatch(command)
            except Error, exception:
                result = ['warn', str(exception)]
            text = json.dumps(result)
            assert '\n' not in text, repr(text)
            if run.debug:
                self.echo("Reply: %r", text)
            self.output.write(text + '\n')

        # Leave all resources.
        for resource in Resource.registry.itervalues():
            if self in resource.clients:
                resource.clients.remove(self)

    def dispatch(self, command):
        if command and isinstance(command, list):
            action = command[0]
            arguments = command[1:]
        else:
            action = command
            arguments = ()
        processor = getattr(self, 'do_%s' % action, None)
        if processor is None:
            raise Error("Unrecognized command: %r" % command)
        try:
            return processor(*arguments)
        except TypeError, exception:
            raise Error(str(exception))

    def do_alter(self, resource, start, end, string):
        resource = Resource.get(resource)
        if resource is None:
            self.error("Resource not found.")
        if self not in resource.clients:
            self.error("Resource is not monitored.", resource)
        for client in resource.clients:
            client.queue.append((resource.ordinal, start, end, string))
        resource.contents = (resource.contents[:start] + string
                             + resource.contents[end:])
        return 'done'

    def do_chat(self, user, string):
        user = Client.get(user)
        if user is None:
            self.error("User not found.")
        user.queue.append(['chat', self.ordinal, string])
        return 'done'

    def do_check(self, resource, start, string):
        resource = Resource.get(resource)
        if resource is None:
            self.error("Resource not found.")
        found = resource.contents[start:start + len(string)]
        if found != string:
            self.error("Expected %r in %s, found %r."
                       % (string, resource, found))
        return 'done'

    def do_create(self, name):
        if not isinstance(name, (str, unicode)):
            self.error("Name should be a string.")
        if Resource.get(name) is not None:
            self.error("Resource name already taken.")
        return ['done', Resource(name).ordinal]

    def do_join(self, resource, md5sum):
        resource = Resource.get(resource)
        if resource is None:
            self.error("Resource not found.")
        if self in resource.clients:
            self.error("Already monitoring.")
        if md5sum == md5_empty:
            self.queue.append((0, 0, resource.contents))
        elif md5sum != resource.md5sum():
            self.error("Checksums do not match.")
        resource.clients.append(self)
        return ['done', resource.ordinal]

    def do_leave(self, resource):
        resource = Resource.get(resource)
        if resource is None:
            self.error("Resource not found.")
        if self not in resource.clients:
            self.error("Was not monitoring.")
        resource.clients.remove(self)
        return 'done'

    def do_login(self, name):
        if not isinstance(name, (str, unicode)):
            self.error("Name should be a string.")
        if Client.get(name) is not None:
            self.error("User name already taken.")
        self.name = name
        return ['done', self.ordinal]

    def do_logout(self):
        if self.name is Client.name:
            self.error("Not logged in.")
        del self.name
        return ['done', self.ordinal]

    def do_resources(self):
        return ['done'] + [
            [key, resource.name]
             for key, resource in sorted(Resource.registry.items())]

    def do_poll(self, *subcommands):
        for command in subcommands:
            result = self.dispatch(command)
            if isinstance(result, (str, unicode)):
                return result
        queue = self.queue
        self.queue = []
        return ['exec'] + queue

    def do_users(self):
        return ['done'] + [
            [key, client.name]
             for key, client in sorted(Client.registry.items())]

    def error(self, diagnostic, resource=None):
        if resource is not None:
            if self in resource.clients:
                resource.clients.remove(self)
                diagnostic = "Sync is now lost: " + diagnostic
            else:
                diagnostic = "Not in sync: " + diagnostic
        raise Error(diagnostic)

    @staticmethod
    def get(name):
        if isinstance(name, int):
            return Client.registry.get(name)
        for key, client in Client.registry.iteritems():
            if name == client.name:
                return client

    def echo(self, format, *arguments):
        run.echo('%s.%d: ' + format, self.host, self.port, *arguments)


class Resource:
    ordinal = 0
    registry = {}

    def __init__(self, name):
        self.name = name
        self.ordinal = Resource.ordinal
        Resource.ordinal += 1
        Resource.registry[self.ordinal] = self
        self.contents = ''
        self.clients = []

    def __repr__(self):
        return repr(self.name)

    @staticmethod
    def get(name):
        if isinstance(name, int):
            return Resource.registry.get(name)
        for key, resource in Resource.registry.iteritems():
            if name == resource.name:
                return resource

    def md5sum(self):
        return hashlib.md5(self.contents).hexdigest()


run = Main()
main = run.main

if __name__ == '__main__':
    main(*sys.argv[1:])
